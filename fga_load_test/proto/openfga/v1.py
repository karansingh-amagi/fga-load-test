# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: openfga/v1/authzmodel.proto, openfga/v1/errors_ignore.proto, openfga/v1/openapi.proto, openfga/v1/openfga.proto, openfga/v1/openfga_service.proto
# plugin: python-betterproto
from dataclasses import dataclass
from datetime import datetime
from typing import AsyncGenerator, Dict, List, Optional

import betterproto
import grpclib


class AuthErrorCode(betterproto.Enum):
    no_auth_error = 0
    auth_failed_invalid_subject = 1001
    auth_failed_invalid_audience = 1002
    auth_failed_invalid_issuer = 1003
    invalid_claims = 1004
    auth_failed_invalid_bearer_token = 1005
    bearer_token_missing = 1010
    unauthenticated = 1500


class ErrorCode(betterproto.Enum):
    no_error = 0
    validation_error = 2000
    authorization_model_not_found = 2001
    authorization_model_resolution_too_complex = 2002
    invalid_write_input = 2003
    cannot_allow_duplicate_tuples_in_one_request = 2004
    cannot_allow_duplicate_types_in_one_request = 2005
    cannot_allow_multiple_references_to_one_relation = 2006
    invalid_continuation_token = 2007
    invalid_tuple_set = 2008
    invalid_check_input = 2009
    invalid_expand_input = 2010
    unsupported_user_set = 2011
    invalid_object_format = 2012
    write_failed_due_to_invalid_input = 2017
    authorization_model_assertions_not_found = 2018
    latest_authorization_model_not_found = 2020
    type_not_found = 2021
    relation_not_found = 2022
    empty_relation_definition = 2023
    invalid_user = 2025
    invalid_tuple = 2027
    unknown_relation = 2028
    store_id_invalid_length = 2030
    assertions_too_many_items = 2033
    id_too_long = 2034
    authorization_model_id_too_long = 2036
    tuple_key_value_not_specified = 2037
    tuple_keys_too_many_or_too_few_items = 2038
    page_size_invalid = 2039
    param_missing_value = 2040
    difference_base_missing_value = 2041
    subtract_base_missing_value = 2042
    object_too_long = 2043
    relation_too_long = 2044
    type_definitions_too_few_items = 2045
    type_invalid_length = 2046
    type_invalid_pattern = 2047
    relations_too_few_items = 2048
    relations_too_long = 2049
    relations_invalid_pattern = 2050
    object_invalid_pattern = 2051
    query_string_type_continuation_token_mismatch = 2052
    exceeded_entity_limit = 2053
    invalid_contextual_tuple = 2054
    duplicate_contextual_tuple = 2055
    invalid_authorization_model = 2056
    unsupported_schema_version = 2057


class InternalErrorCode(betterproto.Enum):
    no_internal_error = 0
    internal_error = 4000
    cancelled = 4003
    deadline_exceeded = 4004
    already_exists = 4005
    resource_exhausted = 4006
    failed_precondition = 4007
    aborted = 4008
    out_of_range = 4009
    unavailable = 4010
    data_loss = 4011


class NotFoundErrorCode(betterproto.Enum):
    no_not_found_error = 0
    undefined_endpoint = 5000
    store_id_not_found = 5002
    unimplemented = 5004


class TupleOperation(betterproto.Enum):
    """buf:lint:ignore ENUM_ZERO_VALUE_SUFFIX"""

    TUPLE_OPERATION_WRITE = 0
    TUPLE_OPERATION_DELETE = 1


@dataclass
class AuthorizationModel(betterproto.Message):
    id: str = betterproto.string_field(1)
    schema_version: str = betterproto.string_field(2)
    type_definitions: List["TypeDefinition"] = betterproto.message_field(3)


@dataclass
class TypeDefinition(betterproto.Message):
    type: str = betterproto.string_field(1)
    relations: Dict[str, "Userset"] = betterproto.map_field(
        2, betterproto.TYPE_STRING, betterproto.TYPE_MESSAGE
    )
    # A map whose keys are the name of the relation and whose value is the
    # Metadata for that relation.
    metadata: "Metadata" = betterproto.message_field(3)


@dataclass
class Relation(betterproto.Message):
    name: str = betterproto.string_field(1)
    rewrite: "Userset" = betterproto.message_field(2)
    type_info: "RelationTypeInfo" = betterproto.message_field(3)


@dataclass
class RelationTypeInfo(betterproto.Message):
    directly_related_user_types: List["RelationReference"] = betterproto.message_field(
        1
    )


@dataclass
class Metadata(betterproto.Message):
    relations: Dict[str, "RelationMetadata"] = betterproto.map_field(
        1, betterproto.TYPE_STRING, betterproto.TYPE_MESSAGE
    )


@dataclass
class RelationMetadata(betterproto.Message):
    directly_related_user_types: List["RelationReference"] = betterproto.message_field(
        1
    )


@dataclass
class RelationReference(betterproto.Message):
    """
    RelationReference represents a relation of a particular object type (e.g.
    'document#viewer').
    """

    type: str = betterproto.string_field(1)
    relation: str = betterproto.string_field(2, group="relation_or_wildcard")
    wildcard: "Wildcard" = betterproto.message_field(3, group="relation_or_wildcard")


@dataclass
class Wildcard(betterproto.Message):
    pass


@dataclass
class Usersets(betterproto.Message):
    child: List["Userset"] = betterproto.message_field(1)


@dataclass
class Difference(betterproto.Message):
    base: "Userset" = betterproto.message_field(1)
    subtract: "Userset" = betterproto.message_field(2)


@dataclass
class Userset(betterproto.Message):
    this: "DirectUserset" = betterproto.message_field(1, group="userset")
    computed_userset: "ObjectRelation" = betterproto.message_field(2, group="userset")
    tuple_to_userset: "TupleToUserset" = betterproto.message_field(3, group="userset")
    union: "Usersets" = betterproto.message_field(4, group="userset")
    intersection: "Usersets" = betterproto.message_field(5, group="userset")
    difference: "Difference" = betterproto.message_field(6, group="userset")


@dataclass
class DirectUserset(betterproto.Message):
    """
    A DirectUserset is a sentinel message for referencing the direct members
    specified by an object/relation mapping.
    """

    pass


@dataclass
class ObjectRelation(betterproto.Message):
    object: str = betterproto.string_field(1)
    relation: str = betterproto.string_field(2)


@dataclass
class TupleToUserset(betterproto.Message):
    # The target object/relation
    tupleset: "ObjectRelation" = betterproto.message_field(1)
    computed_userset: "ObjectRelation" = betterproto.message_field(2)


@dataclass
class ValidationErrorMessageResponse(betterproto.Message):
    code: "ErrorCode" = betterproto.enum_field(1)
    message: str = betterproto.string_field(2)


@dataclass
class InternalErrorMessageResponse(betterproto.Message):
    code: "InternalErrorCode" = betterproto.enum_field(1)
    message: str = betterproto.string_field(2)


@dataclass
class PathUnknownErrorMessageResponse(betterproto.Message):
    code: "NotFoundErrorCode" = betterproto.enum_field(1)
    message: str = betterproto.string_field(2)


@dataclass
class ErrorMessageRequest(betterproto.Message):
    pass


@dataclass
class Object(betterproto.Message):
    """
    Object represents an OpenFGA Object. An Object is composed of a type and
    identifier (e.g. 'document:1') See https://openfga.dev/docs/concepts#what-
    is-an-object
    """

    type: str = betterproto.string_field(1)
    id: str = betterproto.string_field(2)


@dataclass
class TupleKey(betterproto.Message):
    object: str = betterproto.string_field(1)
    relation: str = betterproto.string_field(2)
    user: str = betterproto.string_field(3)


@dataclass
class Tuple(betterproto.Message):
    key: "TupleKey" = betterproto.message_field(1)
    timestamp: datetime = betterproto.message_field(2)


@dataclass
class TupleKeys(betterproto.Message):
    tuple_keys: List["TupleKey"] = betterproto.message_field(1)


@dataclass
class ContextualTupleKeys(betterproto.Message):
    tuple_keys: List["TupleKey"] = betterproto.message_field(1)


@dataclass
class UsersetTree(betterproto.Message):
    """A UsersetTree contains the result of an Expansion."""

    root: "UsersetTreeNode" = betterproto.message_field(1)


@dataclass
class UsersetTreeLeaf(betterproto.Message):
    """
    A leaf node contains either - a set of users (which may be individual
    users, or usersets   referencing other relations) - a computed node, which
    is the result of a computed userset   value in the authorization model - a
    tupleToUserset nodes, containing the result of expanding   a tupleToUserset
    value in a authorization model.
    """

    users: "UsersetTreeUsers" = betterproto.message_field(1, group="value")
    computed: "UsersetTreeComputed" = betterproto.message_field(2, group="value")
    tuple_to_userset: "UsersetTreeTupleToUserset" = betterproto.message_field(
        3, group="value"
    )


@dataclass
class UsersetTreeNodes(betterproto.Message):
    nodes: List["UsersetTreeNode"] = betterproto.message_field(1)


@dataclass
class UsersetTreeUsers(betterproto.Message):
    users: List[str] = betterproto.string_field(1)


@dataclass
class UsersetTreeComputed(betterproto.Message):
    userset: str = betterproto.string_field(1)


@dataclass
class UsersetTreeTupleToUserset(betterproto.Message):
    tupleset: str = betterproto.string_field(1)
    computed: List["UsersetTreeComputed"] = betterproto.message_field(2)


@dataclass
class UsersetTreeDifference(betterproto.Message):
    base: "UsersetTreeNode" = betterproto.message_field(1)
    subtract: "UsersetTreeNode" = betterproto.message_field(2)


@dataclass
class UsersetTreeNode(betterproto.Message):
    name: str = betterproto.string_field(1)
    leaf: "UsersetTreeLeaf" = betterproto.message_field(2, group="value")
    difference: "UsersetTreeDifference" = betterproto.message_field(5, group="value")
    union: "UsersetTreeNodes" = betterproto.message_field(6, group="value")
    intersection: "UsersetTreeNodes" = betterproto.message_field(7, group="value")


@dataclass
class Assertion(betterproto.Message):
    tuple_key: "TupleKey" = betterproto.message_field(1)
    expectation: bool = betterproto.bool_field(2)


@dataclass
class Assertions(betterproto.Message):
    assertions: List["Assertion"] = betterproto.message_field(1)


@dataclass
class TupleChange(betterproto.Message):
    tuple_key: "TupleKey" = betterproto.message_field(1)
    operation: "TupleOperation" = betterproto.enum_field(2)
    timestamp: datetime = betterproto.message_field(3)


@dataclass
class Store(betterproto.Message):
    id: str = betterproto.string_field(1)
    name: str = betterproto.string_field(2)
    created_at: datetime = betterproto.message_field(3)
    updated_at: datetime = betterproto.message_field(4)
    deleted_at: datetime = betterproto.message_field(5)


@dataclass
class ListObjectsRequest(betterproto.Message):
    store_id: str = betterproto.string_field(1)
    authorization_model_id: str = betterproto.string_field(2)
    type: str = betterproto.string_field(3)
    relation: str = betterproto.string_field(4)
    user: str = betterproto.string_field(5)
    contextual_tuples: "ContextualTupleKeys" = betterproto.message_field(6)


@dataclass
class ListObjectsResponse(betterproto.Message):
    objects: List[str] = betterproto.string_field(1)


@dataclass
class StreamedListObjectsRequest(betterproto.Message):
    store_id: str = betterproto.string_field(1)
    authorization_model_id: str = betterproto.string_field(2)
    type: str = betterproto.string_field(3)
    relation: str = betterproto.string_field(4)
    user: str = betterproto.string_field(5)
    contextual_tuples: "ContextualTupleKeys" = betterproto.message_field(6)


@dataclass
class StreamedListObjectsResponse(betterproto.Message):
    """The response for a StreamedListObjects RPC."""

    object: str = betterproto.string_field(1)


@dataclass
class ReadRequest(betterproto.Message):
    store_id: str = betterproto.string_field(1)
    tuple_key: "TupleKey" = betterproto.message_field(2)
    page_size: Optional[int] = betterproto.message_field(
        3, wraps=betterproto.TYPE_INT32
    )
    continuation_token: str = betterproto.string_field(4)


@dataclass
class ReadResponse(betterproto.Message):
    tuples: List["Tuple"] = betterproto.message_field(1)
    continuation_token: str = betterproto.string_field(2)


@dataclass
class WriteRequest(betterproto.Message):
    store_id: str = betterproto.string_field(1)
    writes: "TupleKeys" = betterproto.message_field(2)
    deletes: "TupleKeys" = betterproto.message_field(3)
    authorization_model_id: str = betterproto.string_field(4)


@dataclass
class WriteResponse(betterproto.Message):
    pass


@dataclass
class CheckRequest(betterproto.Message):
    store_id: str = betterproto.string_field(1)
    tuple_key: "TupleKey" = betterproto.message_field(2)
    contextual_tuples: "ContextualTupleKeys" = betterproto.message_field(3)
    authorization_model_id: str = betterproto.string_field(4)
    # Defaults to false. Making it true has performance implications.
    trace: bool = betterproto.bool_field(5)


@dataclass
class CheckResponse(betterproto.Message):
    allowed: bool = betterproto.bool_field(1)
    # For internal use only.
    resolution: str = betterproto.string_field(2)


@dataclass
class ExpandRequest(betterproto.Message):
    store_id: str = betterproto.string_field(1)
    tuple_key: "TupleKey" = betterproto.message_field(2)
    authorization_model_id: str = betterproto.string_field(3)


@dataclass
class ExpandResponse(betterproto.Message):
    tree: "UsersetTree" = betterproto.message_field(1)


@dataclass
class ReadAuthorizationModelRequest(betterproto.Message):
    store_id: str = betterproto.string_field(1)
    id: str = betterproto.string_field(2)


@dataclass
class ReadAuthorizationModelResponse(betterproto.Message):
    authorization_model: "AuthorizationModel" = betterproto.message_field(1)


@dataclass
class WriteAuthorizationModelRequest(betterproto.Message):
    store_id: str = betterproto.string_field(1)
    type_definitions: List["TypeDefinition"] = betterproto.message_field(2)
    schema_version: str = betterproto.string_field(3)


@dataclass
class WriteAuthorizationModelResponse(betterproto.Message):
    authorization_model_id: str = betterproto.string_field(1)


@dataclass
class ReadAuthorizationModelsRequest(betterproto.Message):
    store_id: str = betterproto.string_field(1)
    page_size: Optional[int] = betterproto.message_field(
        2, wraps=betterproto.TYPE_INT32
    )
    continuation_token: str = betterproto.string_field(3)


@dataclass
class ReadAuthorizationModelsResponse(betterproto.Message):
    authorization_models: List["AuthorizationModel"] = betterproto.message_field(1)
    continuation_token: str = betterproto.string_field(2)


@dataclass
class WriteAssertionsRequest(betterproto.Message):
    store_id: str = betterproto.string_field(1)
    authorization_model_id: str = betterproto.string_field(2)
    assertions: List["Assertion"] = betterproto.message_field(3)


@dataclass
class WriteAssertionsResponse(betterproto.Message):
    pass


@dataclass
class ReadAssertionsRequest(betterproto.Message):
    store_id: str = betterproto.string_field(1)
    authorization_model_id: str = betterproto.string_field(2)


@dataclass
class ReadAssertionsResponse(betterproto.Message):
    authorization_model_id: str = betterproto.string_field(1)
    assertions: List["Assertion"] = betterproto.message_field(2)


@dataclass
class ReadChangesRequest(betterproto.Message):
    store_id: str = betterproto.string_field(1)
    type: str = betterproto.string_field(2)
    page_size: Optional[int] = betterproto.message_field(
        3, wraps=betterproto.TYPE_INT32
    )
    continuation_token: str = betterproto.string_field(4)


@dataclass
class ReadChangesResponse(betterproto.Message):
    changes: List["TupleChange"] = betterproto.message_field(1)
    continuation_token: str = betterproto.string_field(2)


@dataclass
class CreateStoreRequest(betterproto.Message):
    name: str = betterproto.string_field(1)


@dataclass
class CreateStoreResponse(betterproto.Message):
    id: str = betterproto.string_field(1)
    name: str = betterproto.string_field(2)
    created_at: datetime = betterproto.message_field(3)
    updated_at: datetime = betterproto.message_field(4)


@dataclass
class UpdateStoreRequest(betterproto.Message):
    store_id: str = betterproto.string_field(1)
    name: str = betterproto.string_field(2)


@dataclass
class UpdateStoreResponse(betterproto.Message):
    id: str = betterproto.string_field(1)
    name: str = betterproto.string_field(2)
    created_at: datetime = betterproto.message_field(3)
    updated_at: datetime = betterproto.message_field(4)


@dataclass
class DeleteStoreRequest(betterproto.Message):
    store_id: str = betterproto.string_field(1)


@dataclass
class DeleteStoreResponse(betterproto.Message):
    pass


@dataclass
class GetStoreRequest(betterproto.Message):
    store_id: str = betterproto.string_field(1)


@dataclass
class GetStoreResponse(betterproto.Message):
    id: str = betterproto.string_field(1)
    name: str = betterproto.string_field(2)
    created_at: datetime = betterproto.message_field(3)
    updated_at: datetime = betterproto.message_field(4)


@dataclass
class ListStoresRequest(betterproto.Message):
    page_size: Optional[int] = betterproto.message_field(
        1, wraps=betterproto.TYPE_INT32
    )
    continuation_token: str = betterproto.string_field(2)


@dataclass
class ListStoresResponse(betterproto.Message):
    stores: List["Store"] = betterproto.message_field(1)
    continuation_token: str = betterproto.string_field(2)


class OpenFGAServiceStub(betterproto.ServiceStub):
    async def read(
        self,
        *,
        store_id: str = "",
        tuple_key: Optional["TupleKey"] = None,
        page_size: Optional[int] = None,
        continuation_token: str = "",
    ) -> ReadResponse:
        request = ReadRequest()
        request.store_id = store_id
        if tuple_key is not None:
            request.tuple_key = tuple_key
        if page_size is not None:
            request.page_size = page_size
        request.continuation_token = continuation_token

        return await self._unary_unary(
            "/openfga.v1.OpenFGAService/Read",
            request,
            ReadResponse,
        )

    async def write(
        self,
        *,
        store_id: str = "",
        writes: Optional["TupleKeys"] = None,
        deletes: Optional["TupleKeys"] = None,
        authorization_model_id: str = "",
    ) -> WriteResponse:
        request = WriteRequest()
        request.store_id = store_id
        if writes is not None:
            request.writes = writes
        if deletes is not None:
            request.deletes = deletes
        request.authorization_model_id = authorization_model_id

        return await self._unary_unary(
            "/openfga.v1.OpenFGAService/Write",
            request,
            WriteResponse,
        )

    async def check(
        self,
        *,
        store_id: str = "",
        tuple_key: Optional["TupleKey"] = None,
        contextual_tuples: Optional["ContextualTupleKeys"] = None,
        authorization_model_id: str = "",
        trace: bool = False,
    ) -> CheckResponse:
        request = CheckRequest()
        request.store_id = store_id
        if tuple_key is not None:
            request.tuple_key = tuple_key
        if contextual_tuples is not None:
            request.contextual_tuples = contextual_tuples
        request.authorization_model_id = authorization_model_id
        request.trace = trace

        return await self._unary_unary(
            "/openfga.v1.OpenFGAService/Check",
            request,
            CheckResponse,
        )

    async def expand(
        self,
        *,
        store_id: str = "",
        tuple_key: Optional["TupleKey"] = None,
        authorization_model_id: str = "",
    ) -> ExpandResponse:
        request = ExpandRequest()
        request.store_id = store_id
        if tuple_key is not None:
            request.tuple_key = tuple_key
        request.authorization_model_id = authorization_model_id

        return await self._unary_unary(
            "/openfga.v1.OpenFGAService/Expand",
            request,
            ExpandResponse,
        )

    async def read_authorization_models(
        self,
        *,
        store_id: str = "",
        page_size: Optional[int] = None,
        continuation_token: str = "",
    ) -> ReadAuthorizationModelsResponse:
        request = ReadAuthorizationModelsRequest()
        request.store_id = store_id
        if page_size is not None:
            request.page_size = page_size
        request.continuation_token = continuation_token

        return await self._unary_unary(
            "/openfga.v1.OpenFGAService/ReadAuthorizationModels",
            request,
            ReadAuthorizationModelsResponse,
        )

    async def read_authorization_model(
        self, *, store_id: str = "", id: str = ""
    ) -> ReadAuthorizationModelResponse:
        request = ReadAuthorizationModelRequest()
        request.store_id = store_id
        request.id = id

        return await self._unary_unary(
            "/openfga.v1.OpenFGAService/ReadAuthorizationModel",
            request,
            ReadAuthorizationModelResponse,
        )

    async def write_authorization_model(
        self,
        *,
        store_id: str = "",
        type_definitions: List["TypeDefinition"] = [],
        schema_version: str = "",
    ) -> WriteAuthorizationModelResponse:
        request = WriteAuthorizationModelRequest()
        request.store_id = store_id
        if type_definitions is not None:
            request.type_definitions = type_definitions
        request.schema_version = schema_version

        return await self._unary_unary(
            "/openfga.v1.OpenFGAService/WriteAuthorizationModel",
            request,
            WriteAuthorizationModelResponse,
        )

    async def write_assertions(
        self,
        *,
        store_id: str = "",
        authorization_model_id: str = "",
        assertions: List["Assertion"] = [],
    ) -> WriteAssertionsResponse:
        request = WriteAssertionsRequest()
        request.store_id = store_id
        request.authorization_model_id = authorization_model_id
        if assertions is not None:
            request.assertions = assertions

        return await self._unary_unary(
            "/openfga.v1.OpenFGAService/WriteAssertions",
            request,
            WriteAssertionsResponse,
        )

    async def read_assertions(
        self, *, store_id: str = "", authorization_model_id: str = ""
    ) -> ReadAssertionsResponse:
        request = ReadAssertionsRequest()
        request.store_id = store_id
        request.authorization_model_id = authorization_model_id

        return await self._unary_unary(
            "/openfga.v1.OpenFGAService/ReadAssertions",
            request,
            ReadAssertionsResponse,
        )

    async def read_changes(
        self,
        *,
        store_id: str = "",
        type: str = "",
        page_size: Optional[int] = None,
        continuation_token: str = "",
    ) -> ReadChangesResponse:
        request = ReadChangesRequest()
        request.store_id = store_id
        request.type = type
        if page_size is not None:
            request.page_size = page_size
        request.continuation_token = continuation_token

        return await self._unary_unary(
            "/openfga.v1.OpenFGAService/ReadChanges",
            request,
            ReadChangesResponse,
        )

    async def create_store(self, *, name: str = "") -> CreateStoreResponse:
        request = CreateStoreRequest()
        request.name = name

        return await self._unary_unary(
            "/openfga.v1.OpenFGAService/CreateStore",
            request,
            CreateStoreResponse,
        )

    async def update_store(
        self, *, store_id: str = "", name: str = ""
    ) -> UpdateStoreResponse:
        request = UpdateStoreRequest()
        request.store_id = store_id
        request.name = name

        return await self._unary_unary(
            "/openfga.v1.OpenFGAService/UpdateStore",
            request,
            UpdateStoreResponse,
        )

    async def delete_store(self, *, store_id: str = "") -> DeleteStoreResponse:
        request = DeleteStoreRequest()
        request.store_id = store_id

        return await self._unary_unary(
            "/openfga.v1.OpenFGAService/DeleteStore",
            request,
            DeleteStoreResponse,
        )

    async def get_store(self, *, store_id: str = "") -> GetStoreResponse:
        request = GetStoreRequest()
        request.store_id = store_id

        return await self._unary_unary(
            "/openfga.v1.OpenFGAService/GetStore",
            request,
            GetStoreResponse,
        )

    async def list_stores(
        self, *, page_size: Optional[int] = None, continuation_token: str = ""
    ) -> ListStoresResponse:
        request = ListStoresRequest()
        if page_size is not None:
            request.page_size = page_size
        request.continuation_token = continuation_token

        return await self._unary_unary(
            "/openfga.v1.OpenFGAService/ListStores",
            request,
            ListStoresResponse,
        )

    async def streamed_list_objects(
        self,
        *,
        store_id: str = "",
        authorization_model_id: str = "",
        type: str = "",
        relation: str = "",
        user: str = "",
        contextual_tuples: Optional["ContextualTupleKeys"] = None,
    ) -> AsyncGenerator[StreamedListObjectsResponse, None]:
        request = StreamedListObjectsRequest()
        request.store_id = store_id
        request.authorization_model_id = authorization_model_id
        request.type = type
        request.relation = relation
        request.user = user
        if contextual_tuples is not None:
            request.contextual_tuples = contextual_tuples

        async for response in self._unary_stream(
            "/openfga.v1.OpenFGAService/StreamedListObjects",
            request,
            StreamedListObjectsResponse,
        ):
            yield response

    async def list_objects(
        self,
        *,
        store_id: str = "",
        authorization_model_id: str = "",
        type: str = "",
        relation: str = "",
        user: str = "",
        contextual_tuples: Optional["ContextualTupleKeys"] = None,
    ) -> ListObjectsResponse:
        request = ListObjectsRequest()
        request.store_id = store_id
        request.authorization_model_id = authorization_model_id
        request.type = type
        request.relation = relation
        request.user = user
        if contextual_tuples is not None:
            request.contextual_tuples = contextual_tuples

        return await self._unary_unary(
            "/openfga.v1.OpenFGAService/ListObjects",
            request,
            ListObjectsResponse,
        )
